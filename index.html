<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Bivalve, NJ — Tidal Flooding Dashboard</title>

  <!-- Chart.js (CDN) -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>

  <style>
    :root{
      --bg:#0b1220;
      --text:#eaf0ff;
      --muted:#a9b6d3;
      --line:rgba(255,255,255,.08);

      --good:#2dd4bf;
      --minor:#fbbf24;
      --moderate:#fb7185;
      --major:#a78bfa;

      --shadow: 0 20px 60px rgba(0,0,0,.35);
      --radius: 18px;
    }

    *{box-sizing:border-box}

    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
      background:
        radial-gradient(1200px 600px at 20% -10%, rgba(34,211,238,.20), transparent 55%),
        radial-gradient(900px 500px at 90% 10%, rgba(167,139,250,.18), transparent 55%),
        var(--bg);
      color:var(--text);
    }

    .wrap{
      max-width: 1180px;
      margin: 0 auto;
      padding: 22px 18px 26px;
    }

    .hero{
      display:flex;
      gap:18px;
      align-items:stretch;
      margin-bottom:14px;
    }

    .heroCard{
      flex:1;
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
      border: 1px solid var(--line);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 16px 16px 14px;
      position:relative;
      overflow:hidden;
    }

    .heroCard:before{
      content:"";
      position:absolute; inset:-1px;
      background:
        radial-gradient(700px 300px at 20% 0%, rgba(45,212,191,.14), transparent 55%),
        radial-gradient(500px 280px at 90% 20%, rgba(251,113,133,.10), transparent 60%);
      pointer-events:none;
    }

    .heroInner{position:relative}

    .kicker{
      display:flex; gap:10px; align-items:center;
      color:var(--muted);
      font-weight:600;
      letter-spacing:.2px;
      font-size: 12.5px;
      text-transform: uppercase;
    }

    .titleRow{
      display:flex; flex-wrap:wrap; gap:10px; align-items:baseline; justify-content:space-between;
      margin-top:10px;
    }

    h1{
      margin:0;
      font-size: 22px;
      letter-spacing:.2px;
    }

    .pill{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:8px 10px;
      border-radius: 999px;
      border:1px solid var(--line);
      background: rgba(0,0,0,.18);
      font-weight:800;
      font-size: 12.5px;
      white-space:nowrap;
    }

    .dot{
      width:9px;height:9px;border-radius:99px;background:var(--good);
      box-shadow:0 0 0 4px rgba(45,212,191,.15)
    }

    .grid{
      display:grid;
      grid-template-columns: 1.1fr .9fr;
      gap:14px;
      margin-top: 14px;
    }

    @media (max-width: 980px){
      .grid{grid-template-columns:1fr}
    }

    .card{
      background: linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.025));
      border: 1px solid var(--line);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 14px;
      overflow:hidden;
    }

    .cardHeader{
      display:flex; align-items:flex-start; justify-content:space-between; gap:10px;
      margin-bottom: 10px;
    }

    .card h2{
      margin:0;
      font-size: 14px;
      letter-spacing:.2px;
      text-transform: uppercase;
      color: var(--muted);
    }

    /* 4 metrics in hero */
    .liveRow{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
      margin-top: 10px;
    }

    @media (max-width: 560px){
      .liveRow{grid-template-columns:1fr}
    }

    .metric{
      background: rgba(0,0,0,.18);
      border: 1px solid var(--line);
      border-radius: 14px;
      padding: 12px;
      min-height: 88px;
    }

    .metricLabel{
      color:var(--muted);
      font-weight:800;
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing:.2px;
      margin-bottom:8px;
    }

    .metricValue{
      font-size: 28px;
      font-weight: 900;
      letter-spacing:.2px;
      display:flex;
      align-items:baseline;
      gap:8px;
    }

    .unit{
      font-size: 12px;
      color:var(--muted);
      font-weight: 800;
    }

    .mini{
      margin-top:6px;
      color:var(--muted);
      font-size: 12.5px;
      line-height:1.25;
    }

    /* Flood stage tiles: ONLY the names + pills */
    .stages{
      display:grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap:10px;
      margin-top: 8px;
    }

    @media (max-width: 720px){
      .stages{grid-template-columns:1fr}
    }

    .stage{
      border-radius: 14px;
      border: 1px solid var(--line);
      background: rgba(0,0,0,.18);
      padding: 16px 14px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      min-height: 78px;
    }

    .stageName{
      font-weight: 950;
      font-size: 22px;
      letter-spacing:.2px;
    }

    .badge{
      font-weight:950;
      font-size: 13px;
      padding: 10px 14px;
      border-radius: 999px;
      border: 1px solid var(--line);
      background: rgba(255,255,255,.06);
      white-space:nowrap;
    }

    .table{
      width:100%;
      border-collapse: collapse;
      overflow:hidden;
      border-radius: 14px;
      border:1px solid var(--line);
      background: rgba(0,0,0,.18);
    }

    .table th, .table td{
      padding: 10px 10px;
      border-bottom: 1px solid var(--line);
      font-size: 13px;
    }

    .table th{
      text-align:left;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing:.2px;
      font-size: 11px;
      font-weight: 900;
    }

    .table tr:last-child td{border-bottom:none}

    .muted{color:var(--muted)}

    .footerNote{
      margin-top: 10px;
      color: var(--muted);
      font-size: 12.5px;
      line-height:1.25;
    }

    .chartWrap{
      height: 260px;
      width: 100%;
      position: relative;
    }
  </style>
</head>

<body>
  <div class="wrap">

    <!-- HERO -->
    <div class="hero">
      <div class="heroCard">
        <div class="heroInner">
          <div class="kicker">USGS-01412150 · Maurice River at Bivalve, NJ</div>

          <div class="titleRow">
            <h1>Bivalve Tidal Flooding Dashboard</h1>
            <div class="pill" id="liveStagePill">
              <span class="dot" id="liveDot"></span>
              <span id="liveStageText">Loading…</span>
            </div>
          </div>

          <!-- 4 metrics -->
          <div class="liveRow">
            <div class="metric">
              <div class="metricLabel">Current water elevation</div>
              <div class="metricValue"><span id="currentFeet">—</span><span class="unit">ft</span></div>
              <div class="mini" id="currentMeta">Updated: —</div>
            </div>

            <div class="metric">
              <div class="metricLabel">Monthly maximum (this month)</div>
              <div class="metricValue"><span id="monthMaxFeet">—</span><span class="unit">ft</span></div>
              <div class="mini" id="monthMaxMeta">—</div>
            </div>

            <div class="metric">
              <div class="metricLabel">Daily maximum (today)</div>
              <div class="metricValue"><span id="dayMaxFeet">—</span><span class="unit">ft</span></div>
              <div class="mini" id="dayMaxMeta">—</div>
            </div>

            <div class="metric">
              <div class="metricLabel">Daily minimum (today)</div>
              <div class="metricValue"><span id="dayMinFeet">—</span><span class="unit">ft</span></div>
              <div class="mini" id="dayMinMeta">—</div>
            </div>
          </div>

        </div>
      </div>
    </div>

    <div class="grid">

      <!-- LEFT: Flood stages + chart -->
      <div class="card">
        <div class="cardHeader">
          <h2>Flood stages (ft)</h2>
        </div>

        <div class="stages">
          <div class="stage">
            <div class="stageName">Minor</div>
            <div class="badge" style="color:var(--minor)">4.19–5.19</div>
          </div>

          <div class="stage">
            <div class="stageName">Moderate</div>
            <div class="badge" style="color:var(--moderate)">5.19–6.19</div>
          </div>

          <div class="stage">
            <div class="stageName">Major</div>
            <div class="badge" style="color:var(--major)">≥ 6.19</div>
          </div>
        </div>

        <div style="height:12px"></div>

        <div class="cardHeader">
          <h2>Annual tidal flooding counts</h2>
        </div>

        <div class="chartWrap">
          <canvas id="annualChart"></canvas>
        </div>

        <div class="footerNote" id="chartNote">
          Note: <b>sparse data</b> in <b>2000</b> and <b>2001</b>. Current year is computed from live gauge data.
        </div>
      </div>

      <!-- RIGHT: Top 10 table -->
      <div class="card">
        <div class="cardHeader">
          <h2>Top ten highest tides</h2>
        </div>

        <table class="table" aria-label="Top ten highest tides">
          <thead>
            <tr>
              <th>Date</th>
              <th>Height (ft)</th>
              <th>Context</th>
            </tr>
          </thead>
          <tbody id="topTenBody"></tbody>
        </table>
      </div>

    </div>
  </div>

<script>
  // ==========================
  // CONFIG
  // ==========================
  const SITE = "01412150";
  const PRIMARY_PARAM = "72279";    // tidal elevation (NOS)
  const FALLBACK_PARAM = "00065";   // fallback gage height
  const TZ = "America/New_York";

  const THRESH = {
    minorLow: 4.19,
    moderateLow: 5.19,
    majorLow: 6.19
  };

  // Top 10 highest tides contexts (your latest)
  const TOP_TEN = [
    {date:"10-29-2012", ft:7.03, note:"Hurricane Sandy"},
    {date:"11-25-1950", ft:6.60, note:"Historic coastal storm"},
    {date:"04-16-2011", ft:5.80, note:"Coastal storm"},
    {date:"08-04-2020", ft:5.67, note:"Tropical Storm Isaias"},
    {date:"08-27-2011", ft:5.60, note:"Tropical Storm Irene"},
    {date:"01-23-2016", ft:5.58, note:"Winter storm Jonas"},
    {date:"04-19-2022", ft:5.50, note:"Coastal storm"},
    {date:"08-21-2025", ft:5.49, note:"Coastal storm"},
    {date:"10-27-2018", ft:5.41, note:"Coastal storm"},
    {date:"03-09-2024", ft:5.39, note:"Coastal storm"}
  ];

  // Historical annual counts you provided (2000–2025)
  const START_YEAR = 2000;
  const PROVIDED_END_YEAR = 2025;

  const providedMinor = [0,0,1,20,13,25,19,16,20,29,25,30,23,20,23,11,23,34,40,44,35,31,14,41,65,38];
  const providedModerate = [0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,2,0,2,0,1,0,1,0,3,1];
  const providedMajor = providedMinor.map(_=>0); // placeholder

  // ==========================
  // DOM
  // ==========================
  const currentFeetEl = document.getElementById("currentFeet");
  const currentMetaEl = document.getElementById("currentMeta");

  const monthMaxFeetEl = document.getElementById("monthMaxFeet");
  const monthMaxMetaEl = document.getElementById("monthMaxMeta");

  const dayMaxFeetEl = document.getElementById("dayMaxFeet");
  const dayMaxMetaEl = document.getElementById("dayMaxMeta");

  const dayMinFeetEl = document.getElementById("dayMinFeet");
  const dayMinMetaEl = document.getElementById("dayMinMeta");

  const liveStageText = document.getElementById("liveStageText");
  const liveDot = document.getElementById("liveDot");
  const chartNoteEl = document.getElementById("chartNote");

  // ==========================
  // Helpers: time, formatting
  // ==========================
  function fmtNY(iso){
    try{
      const d = new Date(iso);
      return new Intl.DateTimeFormat("en-US", {
        timeZone: TZ, year:"numeric", month:"short", day:"2-digit",
        hour:"2-digit", minute:"2-digit"
      }).format(d);
    }catch(e){ return iso; }
  }

  function getNYParts(date = new Date()){
    const fmt = new Intl.DateTimeFormat("en-US", {
      timeZone: TZ,
      year: "numeric", month: "2-digit", day: "2-digit"
    });
    const parts = fmt.formatToParts(date);
    const y = parts.find(p=>p.type==="year")?.value;
    const m = parts.find(p=>p.type==="month")?.value;
    const d = parts.find(p=>p.type==="day")?.value;
    return { y: Number(y), m: Number(m), d: Number(d) };
  }

  // Start of today in NY, expressed as UTC ISO by constructing a Date from NY y/m/d and adding timezone via toISOString trick:
  // We'll build a UTC ISO range by using Date.UTC and then let USGS interpret as UTC timestamps (it does).
  function startOfTodayNY_ISO(){
    const {y,m,d} = getNYParts(new Date());
    const utc = new Date(Date.UTC(y, m-1, d, 0, 0, 0));
    return utc.toISOString();
  }

  function startOfMonthNY_ISO(){
    const {y,m} = getNYParts(new Date());
    const utc = new Date(Date.UTC(y, m-1, 1, 0, 0, 0));
    return utc.toISOString();
  }

  function nowISO(){
    return new Date().toISOString();
  }

  function classifyStage(ft){
    if (ft >= THRESH.majorLow) return {label:"MAJOR FLOODING", color:"var(--major)", glow:"rgba(167,139,250,.22)"};
    if (ft >= THRESH.moderateLow) return {label:"MODERATE FLOODING", color:"var(--moderate)", glow:"rgba(251,113,133,.22)"};
    if (ft >= THRESH.minorLow) return {label:"MINOR FLOODING", color:"var(--minor)", glow:"rgba(251,191,36,.22)"};
    return {label:"BELOW FLOOD STAGE", color:"var(--good)", glow:"rgba(45,212,191,.18)"};
  }

  // ==========================
  // USGS IV fetch
  // ==========================
  async function fetchIV({startISO=null, endISO=null, parameterCd=PRIMARY_PARAM}={}){
    const url = new URL("https://waterservices.usgs.gov/nwis/iv/");
    url.searchParams.set("format","json");
    url.searchParams.set("sites", SITE);
    url.searchParams.set("parameterCd", parameterCd);
    url.searchParams.set("siteStatus","all");
    url.searchParams.set("agencyCd","USGS");
    if (startISO) url.searchParams.set("startDT", startISO);
    if (endISO) url.searchParams.set("endDT", endISO);

    const res = await fetch(url.toString(), {cache:"no-store"});
    if(!res.ok) throw new Error("USGS IV request failed: " + res.status);
    return await res.json();
  }

  function extractSeries(json){
    const ts = json?.value?.timeSeries?.[0];
    const vals = ts?.values?.[0]?.value || [];
    return vals.map(v=>({ t: v.dateTime, ft: Number(v.value) }))
               .filter(p=>Number.isFinite(p.ft));
  }

  async function fetchWithFallback(opts){
    let json = await fetchIV({...opts, parameterCd: PRIMARY_PARAM});
    let series = extractSeries(json);
    if (series.length) return series;

    json = await fetchIV({...opts, parameterCd: FALLBACK_PARAM});
    series = extractSeries(json);
    return series;
  }

  // ==========================
  // Flood-event counting for a year (episode-based)
  // - Find "episodes" where ft >= minorLow
  // - Track episode peak, then bin it:
  //   peak >= majorLow => major
  //   peak >= moderateLow => moderate
  //   peak >= minorLow => minor
  // ==========================
  function countFloodEvents(points){
    if (!points.length) return {minor:0, moderate:0, major:0};

    // ensure chronological
    points.sort((a,b)=> new Date(a.t) - new Date(b.t));

    let inEvent = false;
    let peak = -Infinity;

    let minor=0, moderate=0, major=0;

    for (const p of points){
      const ft = p.ft;

      if (!inEvent){
        if (ft >= THRESH.minorLow){
          inEvent = true;
          peak = ft;
        }
      } else {
        // in event
        if (ft > peak) peak = ft;

        if (ft < THRESH.minorLow){
          // event ends; bin by peak
          if (peak >= THRESH.majorLow) major++;
          else if (peak >= THRESH.moderateLow) moderate++;
          else if (peak >= THRESH.minorLow) minor++;

          inEvent = false;
          peak = -Infinity;
        }
      }
    }

    // If still inEvent at end, close it
    if (inEvent){
      if (peak >= THRESH.majorLow) major++;
      else if (peak >= THRESH.moderateLow) moderate++;
      else if (peak >= THRESH.minorLow) minor++;
    }

    return {minor, moderate, major};
  }

  async function computeYearCountsLive(year){
    // Pull data month-by-month to keep requests reasonable.
    // We only do this for the CURRENT year (or any extra year beyond 2025).
    const all = [];

    for (let month = 0; month < 12; month++){
      const start = new Date(Date.UTC(year, month, 1, 0, 0, 0));
      const end = (month === 11)
        ? new Date(Date.UTC(year+1, 0, 1, 0, 0, 0))
        : new Date(Date.UTC(year, month+1, 1, 0, 0, 0));

      // Don’t request future months for the current year
      const now = new Date();
      if (start > now) break;

      const series = await fetchWithFallback({startISO: start.toISOString(), endISO: end.toISOString()});
      all.push(...series);
    }

    return countFloodEvents(all);
  }

  // ==========================
  // RENDER: Top 10 table
  // ==========================
  const topTenBody = document.getElementById("topTenBody");
  TOP_TEN.forEach(r=>{
    const tr = document.createElement("tr");
    tr.innerHTML = `
      <td>${r.date}</td>
      <td><b>${r.ft.toFixed(2)}</b></td>
      <td class="muted">${r.note}</td>
    `;
    topTenBody.appendChild(tr);
  });

  // ==========================
  // Chart: build base arrays (2000–2025 provided) + append current year if needed
  // ==========================
  const ny = getNYParts(new Date()).y;
  const END_YEAR = Math.max(PROVIDED_END_YEAR, ny); // extend chart to current year if > 2025
  const YEARS = Array.from({length: END_YEAR - START_YEAR + 1}, (_,i)=> START_YEAR + i);

  // Fill with provided where available; for years beyond 2025, start as null and compute live
  const minorCounts = YEARS.map((y, idx)=>{
    if (y <= PROVIDED_END_YEAR) return providedMinor[y - START_YEAR];
    return null;
  });
  const moderateCounts = YEARS.map((y, idx)=>{
    if (y <= PROVIDED_END_YEAR) return providedModerate[y - START_YEAR];
    return null;
  });
  const majorCounts = YEARS.map((y, idx)=>{
    if (y <= PROVIDED_END_YEAR) return providedMajor[y - START_YEAR];
    return null;
  });

  const ctx = document.getElementById("annualChart");
  const suggestedMin = 0;
  const suggestedMax = Math.max(...providedMinor) + 10;

  const annualChart = new Chart(ctx, {
    type: "bar",
    data: {
      labels: YEARS,
      datasets: [
        { label: "Minor", data: minorCounts, stack: "flood", borderWidth: 0, backgroundColor: "rgba(251,191,36,.85)" },
        { label: "Moderate", data: moderateCounts, stack: "flood", borderWidth: 0, backgroundColor: "rgba(251,113,133,.80)" },
        { label: "Major", data: majorCounts, stack: "flood", borderWidth: 0, backgroundColor: "rgba(167,139,250,.80)" }
      ]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      layout: { padding: { top: 4, right: 6, bottom: 0, left: 6 } },
      plugins: {
        legend: {
          labels: {
            color: "rgba(234,240,255,.85)",
            font: { weight: "800" },
            boxWidth: 18
          }
        },
        tooltip: { enabled: true }
      },
      scales: {
        x: {
          stacked: true,
          ticks: {
            color: "rgba(169,182,211,.9)",
            maxRotation: 0,
            autoSkip: true,
            maxTicksLimit: 8
          },
          grid: { color: "rgba(255,255,255,.06)" }
        },
        y: {
          stacked: true,
          suggestedMin,
          suggestedMax,
          ticks: {
            color: "rgba(169,182,211,.9)",
            maxTicksLimit: 6
          },
          grid: { color: "rgba(255,255,255,.06)" }
        }
      }
    }
  });

  // ==========================
  // Live metrics: current, monthly max, daily max, daily min
  // ==========================
  function setStagePill(ft){
    const cls = classifyStage(ft);
    liveStageText.textContent = cls.label;
    liveDot.style.background = cls.color;
    liveDot.style.boxShadow = `0 0 0 4px ${cls.glow}`;
  }

  function maxPoint(series){
    return series.reduce((a,b)=> b.ft>a.ft?b:a, series[0]);
  }

  function minPoint(series){
    return series.reduce((a,b)=> b.ft<a.ft?b:a, series[0]);
  }

  async function updateLiveMetrics(){
    // Current
    const seriesNow = await fetchWithFallback({});
    if(seriesNow.length === 0) throw new Error("No IV data returned.");

    const last = seriesNow[seriesNow.length - 1];
    currentFeetEl.textContent = last.ft.toFixed(2);
    currentMetaEl.textContent = "Updated: " + fmtNY(last.t);
    setStagePill(last.ft);

    // Monthly max
    const mStart = startOfMonthNY_ISO();
    const mEnd = nowISO();
    const seriesMonth = await fetchWithFallback({startISO: mStart, endISO: mEnd});
    if(seriesMonth.length){
      const mx = maxPoint(seriesMonth);
      monthMaxFeetEl.textContent = mx.ft.toFixed(2);
      monthMaxMetaEl.textContent = "Max @ " + fmtNY(mx.t);
    }else{
      monthMaxFeetEl.textContent = "—";
      monthMaxMetaEl.textContent = "No data this month.";
    }

    // Daily max/min (today)
    const dStart = startOfTodayNY_ISO();
    const dEnd = nowISO();
    const seriesDay = await fetchWithFallback({startISO: dStart, endISO: dEnd});
    if(seriesDay.length){
      const dmx = maxPoint(seriesDay);
      const dmn = minPoint(seriesDay);
      dayMaxFeetEl.textContent = dmx.ft.toFixed(2);
      dayMaxMetaEl.textContent = "Max @ " + fmtNY(dmx.t);
      dayMinFeetEl.textContent = dmn.ft.toFixed(2);
      dayMinMetaEl.textContent = "Min @ " + fmtNY(dmn.t);
    }else{
      dayMaxFeetEl.textContent = "—";
      dayMaxMetaEl.textContent = "No data today.";
      dayMinFeetEl.textContent = "—";
      dayMinMetaEl.textContent = "No data today.";
    }
  }

  // ==========================
  // Live annual floods for "present" year (computed from thresholds)
  // ==========================
  async function updatePresentYearFloodCounts(){
    const currentYear = getNYParts(new Date()).y;

    // Only compute live for years beyond the provided dataset OR for the current year if it is within range
    // (This lets “present” floods always be live.)
    const idx = YEARS.indexOf(currentYear);
    if (idx === -1) return;

    chartNoteEl.innerHTML = `Note: <b>sparse data</b> in <b>2000</b> and <b>2001</b>. <b>${currentYear}</b> is computed from live gauge data using your flood thresholds.`;

    const counts = await computeYearCountsLive(currentYear);

    annualChart.data.datasets[0].data[idx] = counts.minor;
    annualChart.data.datasets[1].data[idx] = counts.moderate;
    annualChart.data.datasets[2].data[idx] = counts.major;

    annualChart.update();
  }

  // ==========================
  // Boot
  // ==========================
  async function boot(){
    try{
      await updateLiveMetrics();
      await updatePresentYearFloodCounts();
    }catch(err){
      console.error(err);
      liveStageText.textContent = "LIVE DATA UNAVAILABLE";
      currentMetaEl.textContent = "Could not load USGS live data.";
      monthMaxMetaEl.textContent = "Could not load monthly window.";
      dayMaxMetaEl.textContent = "Could not load daily window.";
      dayMinMetaEl.textContent = "Could not load daily window.";
    }
  }

  boot();
  setInterval(boot, 5 * 60 * 1000);
</script>
</body>
</html>
